/**
 * 문제 데이터 정의
 * @type {Array<Object>}
 */
window.PROBLEMS = [
  {
    id: "P_FORM_MULTIPART",
    title: "파일 업로드 가능한 form 작성",
    concept: "폼 기본 구성",
    difficulty: "초급",
    tags: ["form", "upload", "request"],
    description: [
      "시나리오: 관리자 페이지에서 `/product/uploadProduct.jsp`로 상품 등록 요청을 보낼 때, 상품 기본 정보와 대표 이미지를 함께 전송해야 합니다.",
      "요구사항: ① HTTP 메서드는 POST, ② 파일 첨부가 가능하도록 `enctype`을 설정, ③ 텍스트 필드(`productName`)와 파일 필드(`productImage`)를 모두 포함, ④ 전송 버튼까지 갖춘 form 마크업을 완성하세요.",
      "검증 포인트: JSP에서 cos/Commons 라이브러리가 multipart 요청을 파싱할 수 있도록 브라우저가 올바른 구조의 요청 본문을 만들어야 합니다.",
    ].join("\n\n"),
    starterCode: [
      '<form action="uploadProduct.jsp" method="POST">',
      "  <!-- TODO: enctype 속성과 파일 입력, 제출 버튼을 완성하세요 -->",
      "</form>",
    ].join("\n"),
    solutionCode: [
      '<form action="uploadProduct.jsp" method="post" enctype="multipart/form-data">',
      '  <label for="productName">상품명</label>',
      '  <input type="text" id="productName" name="productName" />',
      '  <label for="productImage">상품 이미지</label>',
      '  <input type="file" id="productImage" name="productImage" />',
      '  <button type="submit">등록</button>',
      "</form>",
    ].join("\n"),
    explanation:
      '파일 업로드를 위해서는 POST 방식과 multipart/form-data 인코딩이 필수입니다. input type="file"을 통해 브라우저가 파일을 전송할 수 있습니다. JSP에서는 업로드 라이브러리가 multipart 요청을 파싱합니다.',
    learningPoints: [
      "전송 방식과 인코딩 타입이 일치하지 않으면 파일이 전달되지 않습니다.",
      "multipart/form-data를 선언해야 브라우저가 파일 바이너리를 전달합니다.",
      "업로드용 input 요소는 name 속성이 있어야 서버에서 식별할 수 있습니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- uploadProduct.jsp : cos.jar 사용 예시 --%>",
      '<%@ page import="com.oreilly.servlet.MultipartRequest" %>',
      '<%@ page import="com.oreilly.servlet.multipart.DefaultFileRenamePolicy" %>',
      "<%",
      "MultipartRequest multi = new MultipartRequest(",
      "  request,",
      '  application.getRealPath("/upload"),',
      "  5 * 1024 * 1024,",
      '  "UTF-8",',
      "  new DefaultFileRenamePolicy()",
      ");",
      'String productName = multi.getParameter("productName");',
      'String fileName = multi.getFilesystemName("productImage");',
      "%>",
      "<p><%= productName %> 업로드 완료: <%= fileName %></p>",
    ].join("\n"),
    hint: "POST + multipart/form-data 조합은 세트입니다. 파일 입력 요소의 name은 서버에서 사용할 값과 동일해야 합니다.",
    tests: [
      {
        desc: "POST 방식이어야 한다",
        type: "regex",
        pattern: /method\s*=\s*["']post["']/i,
      },
      {
        desc: 'enctype="multipart/form-data" 포함',
        type: "regex",
        pattern: /enctype\s*=\s*["']multipart\/form-data["']/i,
      },
      {
        desc: "file 타입 input 존재",
        type: "regex",
        pattern: /<input[^>]+type\s*=\s*["']file["']/i,
      },
      {
        desc: "action 속성 포함",
        type: "regex",
        pattern: /<form[^>]+action\s*=\s*["'][^"']+["']/i,
      },
    ],
  },
  {
    id: "P_UTF8_ORDER",
    title: "UTF-8 인코딩 순서 맞추기",
    concept: "요청 인코딩",
    difficulty: "초급",
    tags: ["request", "encoding"],
    description: [
      "시나리오: `/member/loginProcess.jsp`에서 POST 방식으로 전달된 `userId`, `password` 파라미터를 읽어 로그인 검증을 수행합니다.",
      "문제: 기존 코드가 `request.getParameter()`를 먼저 호출해 한글 입력이 깨진다는 클레임이 접수됐습니다. 요청 바디 인코딩을 먼저 적용하도록 코드 순서를 조정하세요.",
      '요구사항: ① `request.setCharacterEncoding("UTF-8")`를 모든 `getParameter` 호출보다 위에 둡니다. ② 불필요한 중복 호출을 제거하고, 필요한 파라미터만 정확히 읽도록 정리합니다.',
    ].join("\n\n"),
    starterCode: [
      '<%@ page language="java" contentType="text/html; charset=UTF-8" %>',
      "<%",
      'String userId = request.getParameter("userId");',
      'request.setCharacterEncoding("UTF-8");',
      'String password = request.getParameter("password");',
      "%>",
    ].join("\n"),
    solutionCode: [
      '<%@ page language="java" contentType="text/html; charset=UTF-8" %>',
      "<%",
      'request.setCharacterEncoding("UTF-8");',
      'String userId = request.getParameter("userId");',
      'String password = request.getParameter("password");',
      "%>",
    ].join("\n"),
    explanation:
      "한글 파라미터가 깨지지 않으려면 request.getParameter 호출 전에 setCharacterEncoding을 먼저 실행해야 합니다. 요청 본문을 디코딩한 후에는 인코딩을 되돌릴 수 없습니다.",
    learningPoints: [
      "request.setCharacterEncoding은 POST 본문을 디코딩하기 전에 설정해야 합니다.",
      "getParameter를 한 번이라도 호출한 뒤에는 인코딩을 바꿔도 소용이 없습니다.",
      "jsp 페이지 지시자는 응답 인코딩, request.setCharacterEncoding은 요청 인코딩을 제어합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- loginProcess.jsp --%>",
      "<%",
      'request.setCharacterEncoding("UTF-8");',
      'String userId = request.getParameter("userId");',
      'String password = request.getParameter("password");',
      'if ("jsp123".equals(userId) && "pass".equals(password)) {',
      '  out.println("로그인 성공");',
      "} else {",
      '  out.println("로그인 실패");',
      "}",
      "%>",
    ].join("\n"),
    hint: "모든 getParameter 호출보다 위쪽에 setCharacterEncoding을 두고, 필요 없는 중복 호출을 제거하세요.",
    tests: [
      {
        desc: "setCharacterEncoding이 존재",
        type: "regex",
        pattern: /request\.setCharacterEncoding\s*\(\s*["']UTF-8["']\s*\)/,
      },
      {
        desc: "setCharacterEncoding이 첫 번째 getParameter보다 위에 위치",
        type: "func",
        exec: (code) => {
          const setIdx = code.indexOf("request.setCharacterEncoding");
          const firstGetIdx = code.indexOf("request.getParameter");
          return setIdx !== -1 && firstGetIdx !== -1 && setIdx < firstGetIdx;
        },
      },
      {
        desc: "중복 getParameter 호출 없음",
        type: "func",
        exec: (code) => {
          const matches = [
            ...code.matchAll(/request\.getParameter\("userId"\)/g),
          ];
          return matches.length === 1;
        },
      },
    ],
  },
  {
    id: "P_ENUMERATION_TABLE",
    title: "Enumeration으로 파라미터 테이블 출력",
    concept: "파라미터 열거",
    difficulty: "중급",
    tags: ["request", "enum"],
    description: [
      "시나리오: `/support/inquiryView.jsp`에서 사용자가 제출한 문의 폼의 모든 파라미터를 테이블로 보여줘야 합니다.",
      "요구사항: ① `request.getParameterNames()`로 `Enumeration<String>`을 얻고, ② `while(hasMoreElements())` 루프로 모든 파라미터 이름을 순회하며, ③ 각 이름에 대해 `request.getParameter(name)`으로 값을 조회하고, ④ `<tr><td>name</td><td>value</td></tr>` 형식으로 테이블에 출력하세요.",
      "주의: Enumeration을 사용할 때 `nextElement()` 호출 순서를 지켜야 하며, out.println을 이용해 HTML 행을 문자열로 출력합니다.",
    ].join("\n\n"),
    starterCode: [
      "<table>",
      "  <tr><th>파라미터</th><th>값</th></tr>",
      "  <%",
      "  // TODO: Enumeration을 사용해 request 파라미터를 출력하세요.",
      "  %>",
      "</table>",
    ].join("\n"),
    solutionCode: [
      "<table>",
      "  <tr><th>파라미터</th><th>값</th></tr>",
      "  <%",
      "    Enumeration<String> names = request.getParameterNames();",
      "    while (names.hasMoreElements()) {",
      "      String name = names.nextElement();",
      '      out.println("  <tr><td>" + name + "</td><td>" + request.getParameter(name) + "</td></tr>");',
      "    }",
      "  %>",
      "</table>",
    ].join("\n"),
    explanation:
      "Enumeration을 통해 동적으로 전달된 모든 파라미터 이름을 순회할 수 있습니다. hasMoreElements/nextElement 호출 순서를 지키고, 각 파라미터 값을 request.getParameter로 다시 조회합니다.",
    learningPoints: [
      "Enumeration<String> names = request.getParameterNames(); 패턴을 기억하세요.",
      "while(hasMoreElements()) → nextElement() 호출 순서를 지켜야 안전합니다.",
      "JSP에서 out.println을 이용해 테이블 행을 출력할 때 문자열 결합에 주의합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- requestDump.jsp --%>",
      "<%",
      "Enumeration<String> names = request.getParameterNames();",
      "while (names.hasMoreElements()) {",
      "  String param = names.nextElement();",
      "  String value = request.getParameter(param);",
      '  log(param + "=" + value);',
      "}",
      "%>",
    ].join("\n"),
    hint: "Enumeration은 while 루프로 감싸고, nextElement() 반환값을 각 행에 출력하세요. 제네릭 타입을 명시하면 캐스팅을 줄일 수 있습니다.",
    tests: [
      {
        desc: "Enumeration 선언",
        type: "regex",
        pattern:
          /Enumeration\s*<\s*String\s*>?\s+\w+\s*=\s*request\.getParameterNames\(\)/,
      },
      {
        desc: "hasMoreElements와 nextElement 사용",
        type: "regex",
        pattern:
          /while\s*\(\s*\w+\.hasMoreElements\(\)\s*\)\s*{[\s\S]*\w+\.nextElement\(\)/,
      },
      {
        desc: "테이블 행 출력에 request.getParameter 사용",
        type: "regex",
        pattern: /request\.getParameter\s*\(\s*\w+\s*\)/,
      },
    ],
  },
  {
    id: "P_MULTIVALUES_HOBBY",
    title: "다중 선택 취미 저장",
    concept: "다중값 처리",
    difficulty: "중급",
    tags: ["request", "multi-value"],
    description: [
      "시나리오: 회원 정보 수정 폼에서 `hobby` 이름의 checkbox가 다섯 개 존재하며, 사용자가 선택한 모든 취미를 저장해야 합니다.",
      '현재 코드는 `request.getParameter("hobby")`만 호출해 첫 번째 값만 반영되는 버그가 있습니다.',
      "요구사항: ① `request.getParameterValues(\"hobby\")`로 배열을 확보하고, ② null일 경우 '선택 없음' 메시지를 출력하며, ③ 값이 있을 때는 `독서, 운동, 여행`처럼 쉼표로 연결해 화면에 표시하세요.",
    ].join("\n\n"),
    starterCode: [
      "<%",
      'String hobby = request.getParameter("hobby"); // TODO: 다중 선택 전체를 출력하도록 수정하세요.',
      'String message = hobby == null ? "선택 없음" : hobby;',
      "%>",
      "<p>선택한 취미: <%= message %></p>",
    ].join("\n"),
    solutionCode: [
      "<%",
      'String[] hobbyNames = request.getParameterValues("hobby");',
      'String joined = hobbyNames == null ? "선택 없음" : String.join(", ", hobbyNames);',
      "%>",
      "<p>선택한 취미: <%= joined %></p>",
    ].join("\n"),
    explanation:
      "checkbox는 여러 값을 동시에 보낼 수 있으므로 getParameterValues를 사용해야 합니다. null 여부를 확인하고, 배열을 적절히 변환해 출력합니다.",
    learningPoints: [
      "checkbox는 같은 name을 공유하고, 서버에서는 배열로 처리합니다.",
      "getParameterValues가 null을 반환할 수 있으니 예외 처리가 필요합니다.",
      "String.join을 사용하면 간단하게 출력 문자열을 만들 수 있습니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- profileSave.jsp --%>",
      "<%",
      'String[] hobbies = request.getParameterValues("hobby");',
      "if (hobbies != null) {",
      "  for (String hobby : hobbies) {",
      "    // DB 저장 로직",
      '    log("선택 취미:" + hobby);',
      "  }",
      "} else {",
      '  log("선택된 취미가 없습니다.");',
      "}",
      "%>",
    ].join("\n"),
    hint: "getParameter로는 첫 번째 값만 읽힙니다. 배열이 null일 수 있으니 삼항 연산자나 if 문으로 처리하세요.",
    tests: [
      {
        desc: 'getParameterValues("hobby") 사용',
        type: "regex",
        pattern: /request\.getParameterValues\s*\(\s*["']hobby["']\s*\)/,
      },
      {
        desc: 'getParameter("hobby")를 잘못 사용하지 않음',
        type: "func",
        exec: (code) =>
          !/request\.getParameter\s*\(\s*["']hobby["']\s*\)/.test(code),
      },
      {
        desc: "null 대비 로직 포함",
        type: "regex",
        pattern: /==\s*null|!=\s*null/,
      },
    ],
  },
  {
    id: "P_OREILLY_MULTIPARTREQUEST",
    title: "MultipartRequest로 파일 저장",
    concept: "cos.jar 업로드 처리",
    difficulty: "중급",
    tags: ["upload", "cos"],
    description: [
      "시나리오: `/admin/productUpload.jsp`는 cos.jar의 `MultipartRequest`를 사용해 상품 이미지를 `/upload` 폴더에 저장해야 합니다.",
      "문제: 현재 starter는 `new MultipartRequest(request, saveDir);`처럼 필수 인자가 빠져 있고, 여전히 `request.getParameter`로 값을 읽습니다.",
      '요구사항: ① `MultipartRequest` 생성자에 요청, 저장 경로, 최대 용량, 인코딩, `new DefaultFileRenamePolicy()`까지 5개 인자를 채우고, ② 일반 필드는 `multi.getParameter("productId")`, 파일명은 `multi.getFilesystemName("productImage")`로 읽어 `<p>` 요소에 출력하세요.',
    ].join("\n\n"),
    starterCode: [
      "<%",
      'String saveDir = application.getRealPath("/upload");',
      "int maxSize = 5 * 1024 * 1024;",
      "// TODO: MultipartRequest 생성자를 올바르게 완성하고 multi에서 값을 읽으세요.",
      "MultipartRequest multi = new MultipartRequest(request, saveDir);",
      'String productId = request.getParameter("productId");',
      'String fileName = request.getParameter("productImage");',
      "%>",
      "<p><%= productId %> 이미지: <%= fileName %></p>",
    ].join("\n"),
    solutionCode: [
      "<%",
      'String saveDir = application.getRealPath("/upload");',
      "int maxSize = 5 * 1024 * 1024;",
      "MultipartRequest multi = new MultipartRequest(",
      "  request,",
      "  saveDir,",
      "  maxSize,",
      '  "UTF-8",',
      "  new DefaultFileRenamePolicy()",
      ");",
      'String productId = multi.getParameter("productId");',
      'String fileName = multi.getFilesystemName("productImage");',
      "%>",
      "<p><%= productId %> 이미지: <%= fileName %></p>",
    ].join("\n"),
    explanation:
      "MultipartRequest 생성자에는 요청, 저장 경로, 허용 용량, 인코딩, 파일명 정책이 순서대로 필요합니다. 파일명은 getFilesystemName으로 조회하고, 폼 파라미터는 multi.getParameter로 읽습니다.",
    learningPoints: [
      "MultipartRequest 생성자 인자 순서를 정확히 기억해야 합니다.",
      "DefaultFileRenamePolicy는 중복 파일명을 안전하게 처리해 줍니다.",
      "multipart에서는 request가 아니라 multi에서 파라미터를 읽어야 합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- productUpload.jsp --%>",
      '<%@ page import="com.oreilly.servlet.MultipartRequest" %>',
      '<%@ page import="com.oreilly.servlet.multipart.DefaultFileRenamePolicy" %>',
      "<%",
      'String uploadDir = application.getRealPath("/upload");',
      "MultipartRequest multi = new MultipartRequest(",
      "  request,",
      "  uploadDir,",
      "  5 * 1024 * 1024,",
      '  "UTF-8",',
      "  new DefaultFileRenamePolicy()",
      ");",
      'String productId = multi.getParameter("productId");',
      'String image = multi.getFilesystemName("productImage");',
      "%>",
      "<p>상품 <%= productId %> 이미지 파일: <%= image %></p>",
    ].join("\n"),
    hint: 'getFilesystemName("productImage")로 실제 저장된 이름을 확인하세요. multi.getParameter로 일반 텍스트 필드도 읽을 수 있습니다.',
    tests: [
      {
        desc: "MultipartRequest 생성자 5개 인자",
        type: "regex",
        pattern:
          /new\s+MultipartRequest\s*\(\s*request\s*,[\s\S]*,\s*["']UTF-8["']\s*,\s*new\s+DefaultFileRenamePolicy\s*\(\s*\)\s*\)/,
      },
      {
        desc: 'multi.getFilesystemName("productImage") 사용',
        type: "regex",
        pattern: /multi\.getFilesystemName\s*\(\s*["']productImage["']\s*\)/,
      },
      {
        desc: 'multi.getParameter("productId") 사용',
        type: "regex",
        pattern: /multi\.getParameter\s*\(\s*["']productId["']\s*\)/,
      },
    ],
  },
  {
    id: "P_FILESYSTEM_NAME",
    title: "원본/저장 파일명 출력",
    concept: "업로드 메타데이터",
    difficulty: "중급",
    tags: ["upload", "cos"],
    description: [
      "시나리오: 업로드 처리 서블릿이 `MultipartRequest`를 `request` 속성 `upload`에 담아 `uploadResult.jsp`로 포워딩합니다.",
      "요구사항: ① `productImage` 필드의 업로드 결과에서 원본 파일명(`getOriginalFileName`)과 실제 저장 파일명(`getFilesystemName`)을 모두 읽고, ② 두 값을 `<p>` 태그로 각각 출력하세요.",
      "주의: starter는 저장 파일명만 출력하도록 작성되어 있으므로 원본 파일명 출력 로직을 추가해야 합니다.",
    ].join("\n\n"),
    starterCode: [
      '<%@ page import="com.oreilly.servlet.MultipartRequest" %>',
      '<%@ page import="com.oreilly.servlet.multipart.DefaultFileRenamePolicy" %>',
      "<%",
      'MultipartRequest multi = (MultipartRequest) request.getAttribute("upload");',
      'String saved = multi.getFilesystemName("productImage"); // TODO: 원본 파일명과 함께 출력하세요.',
      "%>",
      "<p>저장 파일명: <%= saved %></p>",
    ].join("\n"),
    solutionCode: [
      "<%",
      'String original = multi.getOriginalFileName("productImage");',
      'String saved = multi.getFilesystemName("productImage");',
      "%>",
      "<p>원본 파일명: <%= original %></p>",
      "<p>저장 파일명: <%= saved %></p>",
    ].join("\n"),
    explanation:
      "cos 라이브러리는 getOriginalFileName과 getFilesystemName을 둘 다 제공합니다. 원본 이름은 사용자가 업로드한 파일명, 저장 이름은 RenamePolicy를 거친 결과입니다.",
    learningPoints: [
      "getOriginalFileName은 확장자 포함 원본명입니다.",
      "RenamePolicy가 적용되면 저장 파일명이 달라질 수 있습니다.",
      "동일한 name의 파일 필드가 여러 개일 때는 반복해서 호출해야 합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- uploadResult.jsp --%>",
      '<%@ page import="com.oreilly.servlet.MultipartRequest" %>',
      "<%",
      'MultipartRequest multi = (MultipartRequest) request.getAttribute("upload");',
      'String original = multi.getOriginalFileName("productImage");',
      'String saved = multi.getFilesystemName("productImage");',
      'out.println("원본 파일명: " + original);',
      'out.println("저장 파일명: " + saved);',
      "%>",
    ].join("\n"),
    hint: "original과 filesystemName 둘 다 조회해서 각각 출력하세요. 호출 대상 name은 productImage입니다.",
    tests: [
      {
        desc: "getOriginalFileName 호출",
        type: "regex",
        pattern: /multi\.getOriginalFileName\s*\(\s*["']productImage["']\s*\)/,
      },
      {
        desc: "getFilesystemName 호출",
        type: "regex",
        pattern: /multi\.getFilesystemName\s*\(\s*["']productImage["']\s*\)/,
      },
    ],
  },
  {
    id: "P_COMMONS_FILEUPLOAD",
    title: "Commons-FileUpload 처리 흐름",
    concept: "Commons FileUpload",
    difficulty: "고급",
    tags: ["upload", "commons"],
    description: [
      "시나리오: `CommonsUploadServlet`은 Apache Commons-FileUpload를 이용해 멀티파트 요청을 파싱하고, 일반 폼 값과 파일 데이터를 분리해야 합니다.",
      "starter는 `parseRequest` 후 항목 이름만 출력하고 있어 실제 분기 로직이 빠져 있습니다.",
      "요구사항: ① `item.isFormField()`가 true일 때는 UTF-8로 문자열을 읽어 로그/출력, ② false일 때는 업로드 경로에 `new File(uploadPath, item.getName())`을 생성해 `item.write()`로 저장하세요.",
    ].join("\n\n"),
    starterCode: [
      "<%",
      "ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory());",
      "List<FileItem> items = upload.parseRequest(request);",
      "for (FileItem item : items) {",
      "  // TODO: isFormField 분기와 파일 저장 로직을 완성하세요.",
      "  out.println(item.getFieldName());",
      "}",
      "%>",
    ].join("\n"),
    solutionCode: [
      "<%",
      "ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory());",
      "List<FileItem> items = upload.parseRequest(request);",
      "for (FileItem item : items) {",
      "  if (item.isFormField()) {",
      '    out.println(item.getFieldName() + "=" + item.getString("UTF-8"));',
      "  } else {",
      "    String fileName = item.getName();",
      "    File store = new File(uploadPath, fileName);",
      "    item.write(store);",
      "  }",
      "}",
      "%>",
    ].join("\n"),
    explanation:
      "Commons-FileUpload는 ServletFileUpload.parseRequest로 요청을 FileItem 리스트로 변환합니다. isFormField로 일반 필드를 구분하고, 파일 항목은 write(new File(...))로 저장합니다.",
    learningPoints: [
      "DiskFileItemFactory와 ServletFileUpload 조합을 기억하세요.",
      "isFormField() true/false 분기에서 처리 로직이 달라집니다.",
      "item.write로 File 객체를 넘겨 실제 파일을 기록합니다.",
    ].join("\n"),
    referenceCode: [
      "// CommonsUploadServlet.java",
      "ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory());",
      'upload.setHeaderEncoding("UTF-8");',
      "List<FileItem> items = upload.parseRequest(request);",
      "for (FileItem item : items) {",
      "  if (item.isFormField()) {",
      '    log(item.getFieldName() + "=" + item.getString("UTF-8"));',
      "  } else {",
      "    File saveFile = new File(uploadPath, item.getName());",
      "    item.write(saveFile);",
      "  }",
      "}",
    ].join("\n"),
    hint: "parseRequest가 반환하는 리스트를 for-each로 순회하면서 isFormField 분기를 나누세요. 파일은 write(new File(...)) 호출로 저장합니다.",
    tests: [
      {
        desc: "ServletFileUpload 또는 DiskFileUpload 사용",
        type: "regex",
        pattern: /(ServletFileUpload|DiskFileUpload)\s+\w+\s*=/,
      },
      {
        desc: "parseRequest 호출",
        type: "regex",
        pattern: /\.parseRequest\s*\(\s*request\s*\)/,
      },
      {
        desc: "isFormField 분기",
        type: "regex",
        pattern: /if\s*\(\s*\w+\.isFormField\(\)\s*\)/,
      },
      {
        desc: "item.write(new File(",
        type: "regex",
        pattern: /item\.write\s*\(\s*new\s+File\s*\(/,
      },
    ],
  },
  {
    id: "P_STATIC_RESOURCES",
    title: "정적 리소스 경로 구성",
    concept: "정적 리소스 관리",
    difficulty: "초급",
    tags: ["resources", "upload"],
    description: [
      "시나리오: JSP 레이아웃에서 공통 CSS와 배너 이미지를 로드할 때 프로젝트 구조 `/WebContent/resources/{css,images}`를 준수해야 합니다.",
      "요구사항: ① `<link>` 태그에 컨텍스트 경로 + `/WebContent/resources/css/style.css`를 배치, ② `<img>` 태그는 `/WebContent/resources/images/banner.jpg`와 같은 정적 리소스를 참조하도록 완성하세요.",
      "검증 포인트: 상대 경로로 인해 404가 발생하지 않도록 `request.getContextPath()`를 활용해 절대 경로를 만듭니다.",
    ].join("\n\n"),
    starterCode: [
      '<link rel="stylesheet" href="">',
      '<img src="" alt="샘플 이미지" />',
    ].join("\n"),
    solutionCode: [
      '<link rel="stylesheet" href="<%= request.getContextPath() %>/WebContent/resources/css/style.css">',
      '<img src="<%= request.getContextPath() %>/WebContent/resources/images/banner.jpg" alt="샘플 이미지" />',
    ].join("\n"),
    explanation:
      "컨텍스트 경로를 prepend해 절대 경로 문제를 피합니다. WebContent/resources 하위 폴더를 명시적으로 참조해야 배포 구조가 유지됩니다.",
    learningPoints: [
      "request.getContextPath()는 항상 앞에 붙여야 합니다.",
      "폴더 구조는 WebContent/resources/{css, images} 형식을 유지합니다.",
      "서버 설정에 따라 상대경로가 깨질 수 있으므로 절대경로를 권장합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- layout.jsp --%>",
      '<link rel="stylesheet" href="<%= request.getContextPath() %>/WebContent/resources/css/style.css">',
      '<img src="<%= request.getContextPath() %>/WebContent/resources/images/logo.png" alt="로고" />',
    ].join("\n"),
    hint: "컨텍스트 경로를 활용해 /WebContent/resources/css 와 images 경로를 정확히 작성하세요.",
    tests: [
      {
        desc: "CSS 경로에 /WebContent/resources/css 포함",
        type: "regex",
        pattern: /resources\/css\/[A-Za-z0-9._-]+\.css/,
      },
      {
        desc: "이미지 경로에 /WebContent/resources/images 포함",
        type: "regex",
        pattern: /resources\/images\/[A-Za-z0-9._-]+\.(png|jpg|jpeg|gif)/,
      },
    ],
  },
  {
    id: "P_PRODUCT_IMAGE_RULE",
    title: "상품 ID로 이미지 저장 규칙",
    concept: "업로드 파일 규칙화",
    difficulty: "중급",
    tags: ["upload", "naming"],
    description: [
      "시나리오: 상품 상세 페이지는 업로드한 이미지를 `상품ID.jpg` 규칙으로 관리하며, `/WebContent/resources/images` 폴더를 사용합니다.",
      "현재 starter는 샘플 이미지 경로를 하드코딩하고 있습니다.",
      '요구사항: ① cos 처리 결과인 `multi.getParameter("productId")` 값을 이용해 `imagePath`를 `{context}/WebContent/resources/images/{id}.jpg` 형태로 만들고, ② `<img>` 태그의 `src`와 `alt`에 반영하세요.',
    ].join("\n\n"),
    starterCode: [
      "<%",
      'String productId = multi.getParameter("productId"); // TODO: 상품 ID 기반 파일명을 구성하세요.',
      'String imagePath = "/WebContent/resources/images/sample.jpg";',
      "%>",
      '<img src="<%= imagePath %>" alt="샘플 이미지" />',
    ].join("\n"),
    solutionCode: [
      "<%",
      'String productId = multi.getParameter("productId");',
      'String imagePath = "/WebContent/resources/images/" + productId + ".jpg";',
      "%>",
      '<img src="<%= imagePath %>" alt="<%= productId %>" />',
    ].join("\n"),
    explanation:
      "업로드 시 파일명을 상품 ID와 확장자로 강제하면 정합성을 유지할 수 있습니다. 뷰에서는 이미지 경로 문자열을 그대로 사용합니다.",
    learningPoints: [
      "파일명을 규칙화하면 조회와 정리를 쉽게 할 수 있습니다.",
      "이미지 경로는 WebContent/resources/images 하위에 둡니다.",
      "alt 속성에는 상품명을 넣어 접근성을 확보하세요.",
    ].join("\n"),
    referenceCode: [
      "<%-- productDetail.jsp --%>",
      "<%",
      'String productId = request.getParameter("productId");',
      'String imageUrl = request.getContextPath() + "/WebContent/resources/images/" + productId + ".jpg";',
      "%>",
      '<img src="<%= imageUrl %>" alt="<%= productId %>" />',
    ].join("\n"),
    hint: 'multi.getParameter("productId")로 ID를 읽고, 문자열 결합으로 이미지 경로를 만드세요.',
    tests: [
      {
        desc: "이미지 경로가 /WebContent/resources/images/ 포함",
        type: "regex",
        pattern: /WebContent\/resources\/images\/\s*\+\s*productId/,
      },
      {
        desc: "확장자가 .jpg",
        type: "regex",
        pattern: /productId\s*\+\s*["']\.jpg["']/,
      },
    ],
  },
  {
    id: "P_PHONE_JOIN",
    title: "전화번호 3분할 결합",
    concept: "입력 데이터 후처리",
    difficulty: "초급",
    tags: ["request"],
    description: [
      "시나리오: 회원 가입 폼에서 전화번호를 `phone` 이름으로 세 입력칸(010 / 1234 / 5678)으로 분리해 제출합니다.",
      'starter는 `getParameter("phone")`로 첫 번째 요소만 읽어와 출력하는 상황입니다.',
      '요구사항: ① `getParameterValues("phone")`로 세 파트를 배열로 받아 null 여부를 검사하고, ② 값이 존재할 경우 `010-1234-5678` 형식으로 합쳐 `<p>` 태그에 출력하세요.',
    ].join("\n\n"),
    starterCode: [
      "<%",
      'String phone = request.getParameter("phone"); // TODO: 세 부분을 모두 합쳐 출력하세요.',
      'String formatted = phone == null ? "" : phone;',
      "%>",
      "<p>전화번호: <%= formatted %></p>",
    ].join("\n"),
    solutionCode: [
      "<%",
      'String[] phoneParts = request.getParameterValues("phone");',
      'String phone = phoneParts == null ? "" : String.join("-", phoneParts);',
      "%>",
      "<p>전화번호: <%= phone %></p>",
    ].join("\n"),
    explanation:
      "동일한 name을 가진 input이 여러 개면 배열로 전달됩니다. null 여부를 체크하고 String.join으로 합치면 깔끔합니다.",
    learningPoints: [
      "getParameterValues는 동일 name의 모든 값을 반환합니다.",
      "null 체크를 하지 않으면 NullPointerException이 발생할 수 있습니다.",
      "String.join을 이용하면 반복문 없이 결합 가능합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- phoneUpdate.jsp --%>",
      "<%",
      'String[] phoneParts = request.getParameterValues("phone");',
      "if (phoneParts != null && phoneParts.length == 3) {",
      '  String fullPhone = String.join("-", phoneParts);',
      '  out.println("전화번호 저장: " + fullPhone);',
      "} else {",
      '  out.println("전화번호 입력이 올바르지 않습니다.");',
      "}",
      "%>",
    ].join("\n"),
    hint: "checkbox와 동일하게 values를 사용하세요. 배열이 null일 때를 고려하면 안전합니다.",
    tests: [
      {
        desc: 'getParameterValues("phone") 사용',
        type: "regex",
        pattern: /getParameterValues\s*\(\s*["']phone["']\s*\)/,
      },
      {
        desc: "하이픈 결합",
        type: "regex",
        pattern: /String\.join\s*\(\s*["']-["']/,
      },
    ],
  },
  {
    id: "P_UPLOAD_PROGRESS_META",
    title: "업로드 진행 메타 정보 출력",
    concept: "업로드 모니터링",
    difficulty: "고급",
    tags: ["upload", "commons"],
    description: [
      "시나리오: 대용량 파일 업로드 페이지에서 업로드 진행률을 로그로 남기고자 합니다. Commons-FileUpload의 `ProgressListener`를 활용하세요.",
      "starter는 `parseRequest` 호출만 존재해 진행률이 전혀 출력되지 않습니다.",
      "요구사항: ① `ServletFileUpload` 인스턴스에 `setProgressListener`를 호출, ② `update` 메서드에서 `pBytesRead`와 `pContentLength`를 사용해 백분율을 계산한 뒤 `out.println` 또는 `System.out.printf`로 출력하세요.",
    ].join("\n\n"),
    starterCode: [
      "<%",
      "DiskFileItemFactory factory = new DiskFileItemFactory();",
      "ServletFileUpload upload = new ServletFileUpload(factory);",
      "// TODO: ProgressListener를 등록하고 진행 상황을 out.println으로 출력하세요.",
      "upload.parseRequest(request);",
      "%>",
    ].join("\n"),
    solutionCode: [
      "<%",
      "DiskFileItemFactory factory = new DiskFileItemFactory();",
      "ServletFileUpload upload = new ServletFileUpload(factory);",
      "upload.setProgressListener(new ProgressListener() {",
      "  public void update(long pBytesRead, long pContentLength, int pItems) {",
      "    double percent = pContentLength == -1 ? 0 : (pBytesRead * 100.0 / pContentLength);",
      '    out.println(String.format("%d/%d (%.1f%%)", pBytesRead, pContentLength, percent));',
      "  }",
      "});",
      "upload.parseRequest(request);",
      "%>",
    ].join("\n"),
    explanation:
      "ProgressListener는 업로드 도중 계속 호출되며, 읽은 바이트와 전체 길이를 제공합니다. parseRequest 전에 리스너를 등록해야 이벤트가 트리거됩니다.",
    learningPoints: [
      "ProgressListener는 setProgressListener로 등록합니다.",
      "총 길이가 -1일 수 있으므로 조건 분기가 필요합니다.",
      "parseRequest를 호출해야 리스너가 실제로 동작합니다.",
    ].join("\n"),
    referenceCode: [
      "// UploadProgressServlet.java",
      "ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory());",
      "upload.setProgressListener(new ProgressListener() {",
      "  public void update(long bytesRead, long contentLength, int items) {",
      "    double percent = contentLength <= 0 ? 0 : (bytesRead * 100.0 / contentLength);",
      '    System.out.printf("Progress: %.1f%%%n", percent);',
      "  }",
      "});",
      "upload.parseRequest(request);",
    ].join("\n"),
    hint: "ServletFileUpload 인스턴스에서 setProgressListener를 호출하고, update 메서드에서 진행률을 계산하세요.",
    tests: [
      {
        desc: "setProgressListener 등록",
        type: "regex",
        pattern: /\.setProgressListener\s*\(/,
      },
      {
        desc: "update 메서드에서 백분율 계산",
        type: "regex",
        pattern: /pBytesRead\s*\*\s*100\.0\s*\/\s*pContentLength/,
      },
      {
        desc: "parseRequest 호출",
        type: "regex",
        pattern: /upload\.parseRequest\s*\(\s*request\s*\)/,
      },
    ],
  },
  {
    id: "P_REQUEST_SUMMARY",
    title: "요청 요약 카드 만들기",
    concept: "요청 진단",
    difficulty: "초급",
    tags: ["request", "summary"],
    description: [
      "시나리오: 디버깅 페이지에서 현재 요청의 파라미터 개수와 본문 크기를 한눈에 확인하고자 합니다.",
      "starter는 HTML 뼈대만 있고 실제 개수/길이를 계산하는 코드가 없습니다.",
      '요구사항: ① `request.getParameterNames()`로 Enumeration을 순회하며 파라미터 수를 카운트하고, ② `request.getContentLength()` 값을 변수에 저장한 뒤, ③ `<div class="summary">` 내부에서 두 정보를 출력하세요.',
    ].join("\n\n"),
    starterCode: [
      '<div class="summary">',
      "  <!-- TODO: 파라미터 수와 컨텐츠 길이를 출력하세요 -->",
      "</div>",
    ].join("\n"),
    solutionCode: [
      "<%",
      "Enumeration<String> names = request.getParameterNames();",
      "int count = 0;",
      "while (names.hasMoreElements()) {",
      "  names.nextElement();",
      "  count++;",
      "}",
      "int length = request.getContentLength();",
      "%>",
      '<div class="summary">',
      "  <p>파라미터 개수: <%= count %></p>",
      "  <p>본문 길이: <%= length %> bytes</p>",
      "</div>",
    ].join("\n"),
    explanation:
      "Enumeration으로 파라미터 개수를 셀 수 있습니다. getContentLength는 POST 본문 크기를 알려주며, -1일 수도 있다는 점을 인지해야 합니다.",
    learningPoints: [
      "Enumerㄹation을 재사용할 수 없으므로 반복 도중 값을 소비합니다.",
      "getContentLength는 길이를 알 수 없으면 -1을 돌려줍니다.",
      "요약 정보를 카드 형태로 보여주면 디버깅에 유용합니다.",
    ].join("\n"),
    referenceCode: [
      "<%-- inspector.jsp --%>",
      "<%",
      "Enumeration<String> params = request.getParameterNames();",
      "int counter = 0;",
      "while (params.hasMoreElements()) {",
      "  params.nextElement();",
      "  counter++;",
      "}",
      'out.println("파라미터 수: " + counter);',
      'out.println("본문 길이: " + request.getContentLength());',
      "%>",
    ].join("\n"),
    hint: "Enumeration을 순회하며 카운트 변수를 증가시키고, request.getContentLength를 읽어 출력하세요.",
    tests: [
      {
        desc: "파라미터 개수 세기",
        type: "regex",
        pattern: /count\+\+/,
      },
      {
        desc: "getContentLength 호출",
        type: "regex",
        pattern: /request\.getContentLength\s*\(\s*\)/,
      },
    ],
  },
];
